JAVA:

UUID.randomUUID().toString()
StringUtils.join(cdVlu.toArray(), ",") );
start()与run()介绍
	1.通过我们在启动线程的时候使用的start，为什么不用run呢？ 因为start()会新开一个线程来执行；而run只是一个普通想法，相当于当前线程来调用，不会启动新线程；

	2.start()只能调用一次，run()可以调用多次
wait虚假唤醒	
	
比较一下ArrayList和LinkedList：
	1.ArrayList是基于数组，LinkedList基于链表实现。
	2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
	3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
	4.查找操作indexOf,lastIndexOf,contains等，两者差不多。
	这里只是理论上分析，事实上也不一定，比如ArrayList在末尾插入和删除数据就不设计到数据移动，不过还是
	有这么个建议：随机访问比较多的话一定要用ArrayList而不是LinkedList，如果需要频繁的插入和删除应该
	考虑用LinkedList来提高性能。
	
	
JSON是一种基于文本的数据交换方式（不支持跨域），而JSONP是一种非官方跨域数据交互协议。

Base64编码？
	为什么会有Base64编码呢？
		因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像ASCII码的控制字符就 不能通过邮件传送。
		这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。
		最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。
		Base64编码应运而生，Base64就是一种 基于64个可打印字符来表示二进制数据的表示方法。
	
	InputStream转Base64？
		1、获取输入流，直接调用方法
		引入

		import org.apache.commons.io.IOUtils;
		import java.util.Base64;

		InputStream resourceAsStream = processService.resourceRead(id,type);
		byte[] bytes = IOUtils.toByteArray(resourceAsStream);
		String encoded = Base64.getEncoder().encodeToString(bytes);
		
		2、前端显示
		HTML中使用：<img src="data:image/png;base64,..." />
	--------------------- 
	作者：killnm 
	来源：CSDN 
	原文：https://blog.csdn.net/qq_36120342/article/details/86579485 
	版权声明：本文为博主原创文章，转载请附上博文链接！
	
	
	public final static List<Map<String, Object>> IS_CHGE_LIST = new ArrayList<Map<String, Object>>() {{
		add(new HashMap<String, Object>(){{ put(IS_CHGE_CD, "Y");put(IS_CHGE_DESC, "是");}});
		add(new HashMap<String, Object>(){{ put(IS_CHGE_CD, "N");put(IS_CHGE_DESC, "否");}});
	}};
	
	
	
什么是实体类，实体对象，子类，子对象：
	比如说类就是一个种类，比如人类，鱼类，狗类。这就是类。

	一类动物是一群动物的总称，如果要具体到某一个人，一条鱼，一只狗，就需要用到对象。

	对象是类的一个具体实例，比如：王力宏，比尔盖茨都是一个人，是人的一个实例，就是人类的一个对象，这就是对象的一个比喻。

	实体类是类的一种，用来描述一个真实存在的事物的类。比如人类，鱼类，狗类。一般都是一个具体存在的事物。

	最后是子类。子类简单地说就是“儿子类”。是相对于父类，也就是“爸爸类”说的。这就牵扯到了面向对象中的继承的概念。
	在继承中，子类继承了父类的所有属性和方法并且可以有新的属性和方法。所以说就是儿子继承了老爹的所有能力并且可以有新的能力。





HashMap<String, String> map = new HashMap<String, String>() {
    {
        put("name", "test");  
        put("age", "20"); 
    }
};
new ArrayList<String>(){
		{
			add("1");
		}
	}

	双括号”{{}}”,用来初始化，使代码简洁易读。
	第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)，
	第二层括弧实际上是一个实例初始化块 (instance initializer block)，这个块在内部匿名类构造时被执行。



1.获取ServletAction上下文对象，getServletContext()获取Servlet上下文对象，getRealPath("upload")获取upload的绝对路径。
2.这个使用于文件上传的时候，把上传的文件存放到项目下的upload文件夹里面，而上面的代码是获取upload在项目下的路径。
    String downloadPath = ServletActionContext.getServletContext().getRealPath("/");


// 将二进制写到文件中
   public void writeFile(byte[] data, File file) throws IOException {

    	FileOutputStream fos = null;
		
		try {
	        fos = new FileOutputStream(file); 
	        if (data != null && data.length > 0)  {
	            fos.write(data,  0,  data.length); 
	        } else {
	            fos.write(new byte[0],  0,  0); 
	        }
	        fos.close(); 
		} catch (IOException ex) {
			throw ex;
		} finally {
			if (fos != null) {
				try {
					fos.close();
				} catch (Exception e) {
				}
			}
		}
    }

// 文件转二进制入库
  public void importHandleFile(File file, Map<String, Object> paraMap) throws PlatformException, IOException {
        if (file != null)  {
            InputStream fis = null;
            try {
                fis = new FileInputStream(file);
                ByteArrayOutputStream arry = new ByteArrayOutputStream();
                int ch;
                while ((ch = fis.read()) != -1)  {
                    arry.write(ch);
                }
                byte[] data = arry.toByteArray();
                paraMap.put("attc",  data);

            } catch (IOException ex) {
                throw ex;
            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (Exception e) {
                    }
                }
            }
        }
        edqTaskMgrDao.insertHandleFile(paraMap);
    }




ConfigManager.java

super()
	默认情况下，在子类所有的构造函数，super()无参方法可以省略的，默认会执行父类的无参数构造函数；
	当需要执行父类有参数的构造函数的时候，需要在子类的构造函数中，指定super(color,foot)，这样就会执行父类的含参数构造函数


public static void main(String[] args) {
    int j = 0;
    for (int i = 0; i < 10; i++) {
        j = (j++);
    }
    System.out.println(j);
}
输出0
	运算 j
	0+j  0
	j++  1
	j=   0 
	=的优先级低，把j++的值给冲掉了。把公式是这段程序误导人。只要把语句改造成j = 0+j++。就很容易理解。
	由于顺序是，先算＋后算＋＋，最后算赋值的=。所以结果是0。这完全取决于编译器，别的语言跟java不一样很正常
	
	