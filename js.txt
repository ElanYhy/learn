JS:
https://www.cnblogs.com/bhan/p/6802644.html
apply call?
	apply()方法 接收两个参数，一个是函数运行的作用域（this），另一个是参数数组。 apply([thisObj [,argArray] ]);
	call()方法 第一个参数和apply()方法的一样，但是传递给函数的参数必须列举出来。 call([thisObject[,arg1 [,arg2 [,...,argn]]]]);




	1. 每个函数都包含两个非继承而来的方法：call()方法和apply()方法。
	2. 相同点：这两个方法的作用是一样的。
	都是在特定的作用域中调用函数，等于设置函数体内this对象的值，以扩充函数赖以运行的作用域。

	一般来说，this总是指向调用某个方法的对象，但是使用call()和apply()方法时，就会改变this的指向。


	apply 方法能劫持(<<Ajax in Action>> 书中用到"劫持"一语，很生动啊)另外一个对象的方法， 





	  Math.max 可以实现得到数组中最大的一项

	因为Math.max 参数里面不支持Math.max([param1,param2]) 也就是数组

	但是它支持Math.max(param1,param2,param3…),所以可以根据刚才apply的那个特点来解决 var max=Math.max.apply(null,array),这样轻易的可以得到一个数组中最大的一项(apply会将一个数组装换为一个参数接一个参数的传递给方法)

			 这块在调用的时候第一个参数给了一个null,这个是因为没有对象去调用这个方法,我只需要用这个方法帮我运算,得到返回的结果就行,.所以直接传递了一个null过去
			 
		 
		 
比较typeof与instanceof
	typeof的定义和用法：返回值是一个字符串，用来说明变量的数据类型。
		(1)、typeof 一般只能返回如下几个结果：number,boolean,string,function,object,undefined。

		(2)、typeof 来获取一个变量是否存在，如 if(typeof a!="undefined"){alert("ok")}，而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错。

		(3)、对于 Array,Null 等特殊对象使用 typeof 一律返回 object，这正是 typeof 的局限性。

	Instanceof定义和用法：instanceof 用于判断一个变量是否属于某个对象的实例。
		var a = new Array(); 
		alert(a instanceof Array);  // true
		alert(a instanceof Object)  // true

		function test(){};
		var a = new test();
		alert(a instanceof test)   // true
		 
		 
		 
		 
$.ajax  ?
	async 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。
	
	$.ajax({
		url:'http://www.baidu.com',
		type:'POST',
		data:data,
		cache:true,
		headers:{},
		beforeSend：function(){},
		success:function(){},
		error:function(){},
		complete:function(){}
	}); 



sessionStorage 、localStorage 和 cookie 之间的区别?
	 共同点：用于浏览器端存储的缓存数据

	不同点：

	(1)、存储内容是否发送到服务器端：当设置了Cookie后，数据会发送到服务器端，造成一定的宽带浪费；

	        web storage,会将数据保存到本地，不会造成宽带浪费；

	(2)、数据存储大小不同：Cookie数据不能超过4K,适用于会话标识；web storage数据存储可以达到5M;

	(3)、数据存储的有效期限不同：cookie只在设置了Cookid过期时间之前一直有效，即使关闭窗口或者浏览器；

	        sessionStorage,仅在关闭浏览器之前有效；localStorage,数据存储永久有效；

	(4)、作用域不同：cookie和localStorage是在同源同窗口中都是共享的；sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；
	
		localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。
		sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。


	不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：
	保存数据：localStorage.setItem(key,value);
	读取数据：localStorage.getItem(key);
	删除单个数据：localStorage.removeItem(key);
	删除所有数据：localStorage.clear();
	得到某个索引的key：localStorage.key(index)
	
	每个浏览器对localstorage的支持大小是不一样的，chrome是5M ，IE10是1630K你可以用下面的js匿名函数测试不同浏览器对localstorage的支持大小
	(function() {
    if(!window.localStorage) {
        console.log('当前浏览器不支持localStorage!')
    }    
    var test = '0123456789';
    var add = function(num) {
        num += num;
        if(num.length == 10240) {
            test = num;
            return;
        }
        add(num);
    }
    add(test);
    var sum = test;
    var show = setInterval(function(){
        sum += test;
        try {
            window.localStorage.removeItem('test');
            window.localStorage.setItem('test', sum);
            console.log(sum.length / 1024 + 'KB');
        } catch(e) {
            alert(sum.length / 1024 + 'KB超出最大限制');
            clearInterval(show);
        }
		}, 0.1)
	})()
	
	
	
	
$(document).ready()方法和window.onload有什么区别？
	 (1)、window.onload方法是在网页中所有的元素(包括元素的所有关联文件)完全加载到浏览器后才执行的。

	 (2)、$(document).ready() 方法可以在DOM载入就绪时就对其进行操纵，并调用执行绑定的函数

	
	
delegate()会在以下两个情况下使用到：

 1、如果你有一个父元素，需要给其下的子元素添加事件，这时你可以使用delegate()了，代码如下：

	$("ul").delegate("li", "click", function(){ $(this).hide(); });
 2、当元素在当前页面中不可用时，可以使用delegate()


JQuery有几种选择器?
	(1)、基本选择器：#id，class,element,*;

	(2)、层次选择器：parent > child，prev + next ，prev ~ siblings

	(3)、基本过滤器选择器：:first，:last ，:not ，:even ，:odd ，:eq ，:gt ，:lt

	(4)、内容过滤器选择器： :contains ，:empty ，:has ，:parent

	(5)、可见性过滤器选择器：:hidden ，:visible

	(6)、属性过滤器选择器：[attribute] ，[attribute=value] ，[attribute!=value] ，[attribute^=value] ，[attribute$=value] ，[attribute*=value]

	(7)、子元素过滤器选择器：:nth-child ，:first-child ，:last-child ，:only-child

	(8)、表单选择器： :input ，:text ，:password ，:radio ，:checkbox ，:submit 等；

	(9)、表单过滤器选择器：:enabled ，:disabled ，:checked ，:selected


$(this) 和 this 关键字在 jQuery 中有何不同？
	$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。

	而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。

js单例模式：
	保证一个类仅有一个实例，并提供一个访问它的全局访问点
	实现？
		闭包配合立即执行函数
		https://www.cnblogs.com/yonglin/p/8080836.html
	单例常用场景？
	　　只需要生成一个唯一对象的时候，比如说页面登录框，只可能有一个登录框，那么你就可以用单例的思想去实现他，
		当然你不用单例的思想实现也行，那带来的结果可能就是你每次要显示登陆框的时候都要重新生成一个登陆框并显示（耗费性能），或者是不小心显示出了两个登录框
	
	
定义函数的方式有两种?
	一种是函数声明，一种是函数表达式(匿名函数)
	
立即执行函数?
	立即执行函数的两种常见形式：
		( function(){…} )()和( function (){…} () )，一个是一个匿名函数包裹在一个括号运算符中，后面再跟一个小括号，另一个是一个匿名函数后面跟一个小括号，然后整个包裹在一个括号运算符中，这两种写法是等价的。
		要想立即执行函数能做到立即执行，要注意两点，一是函数体后面要有小括号()，二是函数体必须是函数表达式而不能是函数声明
	使用立即执行函数的好处:
		通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。
		此时若是想访问全局对象，将全局对象以参数形式传进去即可
		
	匿名函数的调用:
		var abc=function(x,y){ 
			return x+y; 
		} 
		alert(abc(2,3)); // “5” 

		alert((function(x,y){return x+y;})(2,3));// "5"  
		alert((new Function("x","y","return x*y;"))(2,3));// "6"
		大家知道小括号的作用吗？
			小括号能把我们的表达式组合分块，并且每一块，也就是每一对小括号，都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。
			所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号对返回的，就是一个匿名函数的Function对象。
			因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。
			--------------------- 
			作者：clh386 
			来源：CSDN 
			原文：https://blog.csdn.net/clh386/article/details/78560136
闭包？
	闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，
	通过另一个函数访问这个函数的局部变量。			
	例子：
	//循环里面包含闭包函数
	function box1(){
		var arr = [];
		for(var i=0;i<3;i++){
			arr[i] = function(){
				return i;                            //由于这个闭包的关系，他是循环完毕之后才返回，最终结果是4++是5
			}                                        //这个匿名函数里面根本没有i这个变量，所以匿名函数会从父级函数中去找i，
		}                                            //当找到这个i的时候，for循环已经循环完毕了，所以最终会返回5
		return arr;
	}
	alert(box1());                                    //执行5次匿名函数本身
	//alert(box1()[1]);　　　　　　　　　　　　　　　　　　　//执行第2个匿名函数本身
	//alert(box1().length);                            //最终返回的是一个数组，数组的长度为5
	//alert(box1()[0]());                                //数组中的第一个数返回的是5，这是为什么？
	
	
	
	下面这个JS程序的输出是什么：

	function Foo() {
		var i = 0;
		return function() {
			console.log(i++);
		}
	}
	 
	var f1 = Foo(),
		f2 = Foo();
	f1();
	f1();
	f2();
	
	答案：0 1 0
	（1）Function是引用类型：保存在堆中，变量f1,f2是保存在栈中；
	（2）闭包：一个函数（产生新的作用域）定义的局部变量、子函数的作用域在函数内，
			 但是一旦离开了这个函数，局部变量就无法访问，所有通过返回子函数到一个变量f1的方法，让
			 f1指向堆中的函数作用域，这样可以使用局部变量i.
	(3)   过程：
	   第一次f1()  :f1=Foo()中，先执行Foo(): i = 0,return值返回给f1
	 (f1指向子函数   f1()=function(){.....},因为子函数没有 定义i，所以向上找到父函数定义的 i:  )并执行子函数 输出i=0,再自加 i =1(覆盖了父函数Foo 的 i值);
	  第二次f1() : 执行的是子函数 Function(){  ..},输出的是父函数 的 i=1,再自加 i =2;
	  第一次f2():同第一次f1(),不同的是 f2指向堆中一个新的对象 function(){ ...},所有此i非彼i,输出i=0;如果
				   如果再次f2(),那么和第二次f1(),一样输出i=1; 
     
	
JS中for循环变量作用域？
https://blog.csdn.net/kai_l/article/details/50913505	
	js中作用域只有函数作用域和全局作用域，在函数体内使用var 定义的变量，会被提到函数开始处进行定义，作用域为整个函数,常见的误区如下
	var a=[];
	for(var i = 0;i<10;i++){
	   var q = i;
	   a[i]=function(){console.log(q)}
	}
	a[0]()
		
	其中，由于for循环并不是一个函数体，所以for循环中定义的变量q和i是作用域for循环所在的函数体，和a同级，
	i++ 和  q=i 并不是重新定义变量，只是重复赋值，最终循环结束，i = 10,q=9;  
	由于function(){console.log(q)} 并不是立即执行，所以这里的q一直是存储的内存引用，最终所有的a[i]()都是输出 9
	不过，在es6中新增了let命令声明变量，用法和var类似，不过let所声明的变量，只在let命令所在的代码块有效果，for循环的计数器中就很适合let命令
	var a=[];
	for(let i = 0;i<10;i++){
	   ley q = i;
	   a[i]=function(){console.log(q)}
	}
	a[6]()    //这里会输出   6  let声明的变量仅在块级作用域有效，所以这里的i只在本轮循环有效果，每次循环的i其实都是一个新的变量

			

判断数组有哪些方法?
	a instanceof Array
	a.constructor == Array
	Object.prototype.toString.call(a) == [Object Array]


跨域通信有哪些方案，各有什么不同?
	JSONP：由于同源策略的限制，XmlHttpRequest只允许请求当前源，script标签没有同源限制
	通过动态<script>元素使用，使用时为src指定一个跨域url。回调函数处理JSON数据  兼容性好 不支持post
	简述原理与过程：首先在客户端注册一个callback, 然后把callback的名字传给服务器。此时，服务器先生成一个function , function 名字就是传递上来的参数。
	最后将 json 数据直接以入参的方式，放置到 function 中，这样就生成了一段 js 语法的文档，返回给客户端。
	客户端浏览器，解析script标签，并执行返回的 javascript 文档，此时数据作为参数，传入到了客户端预先定义好的 callback 函数里
	  <script> 
	  var url = "http://localhost:8080/crcp/rcp/t99eidt/testjson.do?jsonp=callbackfunction";  
	  var script = document.createElement('script');  
	  script.setAttribute('src', url);  //load javascript   
	  document.getElementsByTagName('head')[0].appendChild(script);  
	   
	  //回调函数 
	   function callbackfunction(data){ 
		var html=JSON.stringify(data.RESULTSET); 
		alert(html); 
	 } 
	 ？？？？？？？？
	 jsonp（利用script标签的跨域能力）跨域、websocket（html5的新特性，是一种新协议）跨域、
	 设置代理服务器（由服务器替我们向不同源的服务器请求数据）、CORS（跨源资源共享，cross origin resource sharing）、
	 iframe跨域、postMessage(包含iframe的页面向iframe传递消息


UMD规范和ES6模块化，Commonjs的对比？

	CommonJS是一个更偏向于服务器端的规范。用于NodeJS 是同步的

	AMD是依赖前置的

	CMD推崇依赖就近，延迟执行。可以把你的依赖写进代码的任意一行

	AMD和CMD都是用difine和require，但是CMD标准倾向于在使用过程中提出依赖，就是不管代码写到哪突然发现需要依赖另一个模块，那就在当前代码用require引入就可以了，规范会帮你搞定预加载，你随便写就可以了。但是AMD标准让你必须提前在头部依赖参数部分写好（没有写好？ 倒回去写好咯）。这就是最明显的区别。

	UMD写一个文件需要兼容不同的加载规范

	ES6通过import、export实现模块的输入输出。其中import命令用于输入其他模块提供的功能，export命令用于规定模块的对外接口。
	


JS中的prototype、__proto__与constructor？
	https://blog.csdn.net/cc18868876837/article/details/81211729
	1、我们需要牢记两点：①__proto__和constructor属性是对象所独有的；② prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有__proto__和constructor属性。
	2、__proto__属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的__proto__属性所指向的那个对象（父对象）里找，一直找，
		直到__proto__属性的终点null，然后返回undefined，通过__proto__属性将对象连接起来的这条链路即我们所谓的原型链。
	3、prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.__proto__ === Foo.prototype。
	4、constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。
	<script>
		function myFunction(){
			var fruits = ["Banana", "Orange", "Apple", "Mango"];
			fruits.t1();

		}
		Array.prototype.t1 = function(){
				var x=document.getElementById("demo");
				x.innerHTML=this.valueOf();
		}
	</script>

事件委托?
	不在事件的发生地设立监听函数，而是在事件发生地的父元素或者祖先元素设置监听器函数，这样可以大大提高性能，因为可以减少绑定事件的元素
	
	
(0, eval)(‘this’) ?
	https://www.cnblogs.com/qianlegeqian/p/3950044.html
	这里用了逗号操作符，逗号操作符总会返回表达式中的最后一项，所以0在这里基本上没有什么用，换成其他任意数值均可
	然后通过”()”来立即执行这个表达式，返回eval
	为eval传入’this’字符串，然后被当做实际的ECMAScript语句来解析
	作用：
		因为在严格模式（"use strict"）下，匿名函数中的this为undefined
		为了防止在严格模式下window变量被赋予undefined，使用(0, eval)(‘this’)就可以把this重新指向window对象

	eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。
	间接调用计算出来的是一个值，而不是引用
	如ECMAScript所说，这是因为两个操作符 - （例子(1,eval)里的）逗号操作符和(例子(eval=eval)里的)等号操作符-对它的操作数执行了GetValue。
	因此，(1,eval)和(eval = eval)计算出一个值，而eval 和 (eval)计算出的是一个引用。
	
	
	
$('xx')[0].files[0]是什么意思？

	
	①首先得明白jQuery对象只能使用jQuery对象的属性和方法，JavaScript对象只能使用JavaScript对象的属性和方法；

	②files[0]是JavaScript的属性；

	③$('xx')是jQuery对象，$('xx')[0]是将jQuery对象：$('xx')转换为JavaScript对象，这样才可以使用JavaScript对象的属性和方法；

	④我们再看这行代码的背景，HTML5支持multiple属性，即<input type="file">可能会添加multiple属性并赋值：multiple="multiple"，即<input type="file" multiple="multiple">，这样一次性可同时上传多张图片，所以获得一张图片的方法就是：$('xx')[0].files[0]

	⑤扩展：

	$('xx')[0].files[0].size可获得文件的大小，单位是字节（B），使用$('xx')[0].files[0].size可用于判断文件的大小。
	
	
	
js中‘0’到底是 true 还是 false ?
	if ('0') alert("'0' is true");
	if ('0' == false) alert("'0' is false");结果是，两次都 alert 了！那么 '0' 到底是 true 还是 false 呢？

	答案是：在js做比较的时候，有这样的三条规则：
	如果比较的两者中有boolean，会把 boolean 先转换为对应的 number，即 0 和 1(false是0,1是true)
	如果比较的双方中有一方为number一方为string，会把string转换为数字
	把string直接转换为boolean的时候，空字符串‘’转换为 false，除此外的一切字符串转换为 true


AJAX 教程?
	AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。
	AJAX 不是新的编程语言，而是一种使用现有标准的新方法。
	AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。
	AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。

	<!DOCTYPE html>
	<html>
	<head>
	<meta charset="utf-8">
	<script>
	function loadXMLDoc()
	{
		var xmlhttp;
		if (window.XMLHttpRequest)
		{
			//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
			xmlhttp=new XMLHttpRequest();
		}
		else
		{
			// IE6, IE5 浏览器执行代码
			xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
		}
		xmlhttp.onreadystatechange=function()
		{
			if (xmlhttp.readyState==4 && xmlhttp.status==200)
			{
				document.getElementById("myDiv").innerHTML=xmlhttp.responseText;
			}
		}
		xmlhttp.open("GET","/try/ajax/ajax_info.txt",true);
		xmlhttp.send();
	}
	</script>
	</head>
	<body>

	<div id="myDiv"><h2>使用 AJAX 修改该文本内容</h2></div>
	<button type="button" onclick="loadXMLDoc()">修改内容</button>

	</body>
	</html>
	
	
Axios?
	axios({
		method: 'post',
		url: '/user/12345',
		data: {
			firstName: 'Fred',
			lastName: 'Flintstone'
		}
	})
	.then(function (response) {
		console.log(response);
	})
	.catch(function (error) {
		console.log(error);
	});
	
	
promise ?
http://es6.ruanyifeng.com/#docs/promise
	Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。
	所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。
	从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
	
	Promise对象有以下两个特点。

	（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
		只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。

	（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。
		只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。
		这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。
	
	有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。
	
	缺点: 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
		第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
	

	Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。
	它们是两个函数，由 JavaScript 引擎提供，不用自己部署。	
		
	resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
	reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
		
	then方法可以接受两个回调函数作为参数。
	第一个回调函数是Promise对象的状态变为resolved时调用，
	第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。	
		
	实例：
		const getJSON = function(url) {
		  const promise = new Promise(function(resolve, reject){
			const handler = function() {
			  if (this.readyState !== 4) {
				return;
			  }
			  if (this.status === 200) {
				resolve(this.response);
			  } else {
				reject(new Error(this.statusText));
			  }
			};
			const client = new XMLHttpRequest();
			client.open("GET", url);
			client.onreadystatechange = handler;
			client.responseType = "json";
			client.setRequestHeader("Accept", "application/json");
			client.send();

		  });

		  return promise;
		};

		getJSON("/posts.json").then(function(json) {
		  console.log('Contents: ' + json);
		}, function(error) {
		  console.error('出错了', error);
		});
		
		
		
		
		
		
		
		
		
		
		
----------------------------------------------------------------------------------------------------------------

Object.defineProperty()？
	Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。
	
比较两个值是否相等？
	ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。
	ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。
	它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。不同之处只有两个：一是+0不等于-0，二是NaN等于自身。
	
	ES5 可以通过下面的代码，部署Object.is。
	Object.defineProperty(Object, 'is', {
	  value: function(x, y) {
		if (x === y) {
		  // 针对+0 不等于 -0的情况
		  return x !== 0 || 1 / x === 1 / y;
		}
		// 针对NaN的情况
		return x !== x && y !== y;
	  },
	  configurable: true,
	  enumerable: false,
	  writable: true
	});
	
	
	
100 以内随机的自然数?
	Math.floor(Math.random() * 100) + 1;
	
	round() 遵循四舍五入把原值转化为指定小数位数Math
	floor()向下舍入为指定小数位数 取整数位
	ceil()向上取整
MVVM？
	MVVM是Model-View-ViewModel的缩写。
	MVVM的设计思想：关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！
	
w3c 制定的 javascript 标准事件模型，以下正确的顺序以及描述是	
	事件捕获->事件处理->事件冒泡	
	
	1.event.stopPropagation()方法

	这是阻止事件的冒泡方法，不让事件向documen上蔓延，但是默认事件任然会执行，当你掉用这个方法的时候，如果点击一个连接，这个连接仍然会被打开，

	2.event.preventDefault()方法

	这是阻止默认事件的方法，调用此方法是，连接不会被打开，但是会发生冒泡，冒泡会传递到上一层的父元素；

	3.return false  ；

	原文：https://blog.csdn.net/wxl1555/article/details/53128966 

	
addEvenListener	
	 addEvenListener方法第三参数是包裹层触发问题 估计执行顺序是先由外向里边执行判断监听参数是否为true，是就立即执行 。
	 false就先放过。 直到点击触发的那个元素才开始由里向外执行未执行的事件
	捕获过程要先于冒泡过程，当第三个参数设置为true就在捕获过程中执行，反之就在冒泡过程中执行处理函数。
	
	事件传递有两种方式：冒泡与捕获。

		事件传递定义了元素事件触发的顺序。 如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 "click" 事件先被触发呢？
		在 冒泡 中，内部元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。
		在 捕获 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即：<div> 元素的点击事件先触发，然后再触发 <p> 元素的点击事件。
		addEventListener() 方法可以指定 "useCapture" 参数来设置传递类型：
			addEventListener(event, function, useCapture);
			useCapture默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。
removeEventListener
	removeEventListener() 方法用于移除由 addEventListener() 方法添加的事件句柄。
	注意： 如果要移除事件句柄，addEventListener() 的执行函数必须使用外部函数，如上实例所示 (myFunction)。
	匿名函数，类似 "document.removeEventListener("event", function(){ myScript });" 该事件是无法移除的。
	
	
	
target	
	在html中通过<a>标签打开一个链接，通过 <a> 标签的 target 属性规定在何处打开链接文档。
	如果在标签<a>中写入target属性，则浏览器会根据target的属性值去打开与其命名或名称相符的 框架<frame>或者窗口.
	在target中还存在四个保留的属性值如下，
	_blank	在新窗口中打开被链接文档。
	_self	默认。在相同的框架中打开被链接文档。
	_parent	在父框架集中打开被链接文档。
	_top	在整个窗口中打开被链接文档。
	framename	在指定的框架中打开被链接文档。
	
title、alt？
	title作为属性时，用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。 
	而alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。
	
js样式？	
	在使用点运算符时，浏览器看到“-”就没法正确解析了，在那种情况下，只能将该变量使用驼峰命名法来表示。
	而使用方括号表示法，"-"被理解为字符串中的内容，该字符串能被正确解析。
	eg:
	inputElement.style.backgroundColor = 'red'; // 这是没问题的
	inputElement.style.background-color = 'red'; // 这是错的，浏览器看不懂啊...
	inputElement.style["background-color"] = 'red'; // 这也是可以的
	
	
	
	
“ECMA中所有函数的参数都是按值传递的”。
	var bb = 1;
	function aa(bb) {
		bb = 2;
		alert(bb);
	};
	aa(bb);
	alert(bb);
	
	
	答案：2 1
	值传递：把把一个值类型（也叫基本类型）传递给另一个变量时，其实是分配了一块新的存储空间，因此就本题来说，在内部改变这个值时，其实在函数外部对这个值没有影响。
	
	
严格模式与混杂模式？
1.<!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器的解析器，用什么文档类型 规范来解析这个文档。
2.严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
3.DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。	
4.HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。
	
	


document.body.clientHeight 
document.body.clientWidth //网页可见区域宽
	clientWidth = width + padding
	clientHeight = height + padding
	offsetWidth = width + padding + border
	offsetHeight = height + padding + border
event.clientX 事件属性返回当事件被触发时鼠标指针相对于浏览器页面（或客户区）的水平坐标。
event.clientY



e.target



arguments 对象
	JavaScript 函数有个内置的对象 arguments 对象。

	argument 对象包含了函数调用的参数数组。

	通过这种方式你可以很方便的找到最大的一个参数的值：

	实例
	x = findMax(1, 123, 500, 115, 44, 88);
	 
	function findMax() {
		var i, max = arguments[0];
		
		if(arguments.length < 2) return max;
	 
		for (i = 0; i < arguments.length; i++) {
			if (arguments[i] > max) {
				max = arguments[i];
			}
		}
		return max;
	}
	
	
JavaScript 有下列哪些数据类型？
	值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。
	引用数据类型(复杂类型)：对象(Object)、数组(Array)、函数(Function)。
	注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。
	
	基本类型变量用八字节内存，存储基本数据类型(数值、布尔值、null和未定义)的值，
	引用类型变量则只保存对对象、数组和函数等引用类型的值的引用(即内存地址)。
	
JavaScript定义var a="40",var b=7,则执行a%b会得到5。
	运算中，+号，数字隐式转换成字符串。其余的运算符号是字符串隐式转换成数字。
	
	
页面的性能指标详解：

	白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止

	首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间

	用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作

	总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间
		参考http://www.cnblogs.com/chuaWeb/p/PerformanceMonitoring.html
	
	
	
	
var myObject = {
    foo: "bar",
    func: function() {
        var self = this;
        console.log(this.foo);  
        console.log(self.foo);  
        (function() {
            console.log(this.foo);  
            console.log(self.foo);  
        }());
    }
};
myObject.func();
程序的输出是什么？	
	依次输出  bar  bar  undefined bar

	理解关键：方法/函数是由谁(对象) 调用 的，方法/函数内部的 this 就指向谁(该对象)；

	注意：被谁调用，不是处于谁的作用域，即使在作用域

	1、func是由myObject调用的，this指向 myObject。
	2、self指向myObject，相当于 myObject的this的副本。
	3、这个立即执行匿名函数表达式（IIFE）是由window调用的，this指向 window 。
	4、IIFE的作用域处于myObject.func的作用域中，本作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的 self。
	
	
alert(typeof((function(){
    alert('Hello World！'); 
    })() 
));
	
	输出： Hello World！undefined
	
	1.先立即执行匿名函数，输出Hello World！
	2.没有写return语句默认返回undefined
	
	
var x = new Boolean(false);
if (x) {
  alert('hi');
}
var y = Boolean(0);
if (y) {
  alert('hello'); 
}
的显示结果是？
	输出：hi

此题考查的是 JS 的类型转换：
	if(x) 这里期望 x 是一个布尔类型的原始值，而 x 是一个对象，任何对象转为布尔值，都为得到 true（切记！在 JS 中，只有
	0，-0，NaN，""，null，undefined 这六个值转布尔值时，结果为 false）。
	题目的第二部分，一定要注意 y = Boolean(0)，而不是 y = new Boolean(0)。这两个有很大区别，用 new 调用构造函数会新建一个布尔对象，
	此处没有加 new，进行的是显示类型转换，正如上述第一条所说，0 转换布尔，结果为 false，所以此时 y 的值就是 false。
	如果加了 new，那么 y 就是一个 Boolean 类型的对象，执行 if(y) 时，对象转布尔，始终是 true，所以结果会与不加 new 的时候相反。
	
	undefined和null与任何有意义的值比较返回的都是false，但是null与undefined之间互相比较返回的是true。
	alert(undefined==null) ？
		undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true。 
		===在判断值是否相同的同时还判断类型是否相同，undefined类型为undefined，null类型为object，因此为false


History 对象
	length      返回浏览器历史列表中的URL数量
	back()      加载 history 列表中的前一个URL
	forward() 加载 history 列表中的下一个URL
	go()         加载history列表中的某个具体页面。
	
	
var array=[-1,1,3,4,6,10]; 
array.sort((a,b)=>Math.abs(a-3)-Math.abs(b-3));

	sort() 方法用于对数组的元素进行排序，参数决定排序的顺序。
	原数组var array=[-1,1,3,4,6,10];
	参数(a,b)=>Math.abs(a-3)-Math.abs(b-3)：即数值减3的绝对值[4，2，0，1，3，7]作为参数决定排序。
	根据绝对值减3大小排列[0，1，2，3，4，7]，对应的原数组排序后为[3，4，1，6，-1，10]
	
	
	
JS中，可以将对象分为“内部对象”、“宿主对象”和“自定义对象”三种。
	1，内部对象
	js中的内部对象包括Array、Boolean、Date、Function、Global、Math、Number、Object、RegExp、String以及各种错误类对象，包括Error、EvalError、RangeError、ReferenceError、SyntaxError和TypeError。
	其中Global和Math这两个对象又被称为“内置对象”，这两个对象在脚本程序初始化时被创建，不必实例化这两个对象。

	2.宿主对象

	宿主对象就是执行JS脚本的环境提供的对象。对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，所以又称为浏览器对象，如IE、Firefox等浏览器提供的对象。
	不同的浏览器提供的宿主对象可能不同，即使提供的对象相同，其实现方式也大相径庭！这会带来浏览器兼容问题，增加开发难度。
	浏览器对象有很多，如Window和Documen，Element，form，image，等等。

	3.自定义对象

	顾名思义，就是开发人员自己定义的对象。JS允许使用自定义对象，使JS应用及功能得到扩充
		
	
JSX	
	React JSX 使用JSX代替常规的JavaScript
	
	
	
说一说常见的请求头和相应头都有什么呢？
	1)请求(客户端->服务端[request]) 
		GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) 
		Accept: */*(客户端能接收的资源类型) 
		Accept-Language: en-us(客户端接收的语言类型) 
		Connection: Keep-Alive(维护客户端和服务端的连接关系) 
		Host: localhost:8080(连接的目标主机和端口号) 
		Referer: http://localhost/links.asp(告诉服务器我来自于哪里) 
		User-Agent: Mozilla/4.0(客户端版本号的名字) 
		Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) 
		If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间)  
		Cookie(客户端暂存服务端的信息) 
		Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间)


	2)响应(服务端->客户端[response])
		HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)
		Location: http://www.baidu.com(服务端需要客户端访问的页面路径) 
		Server:apache tomcat(服务端的Web服务端名)
		Content-Encoding: gzip(服务端能够发送压缩编码类型) 
		Content-Length: 80(服务端发送的压缩数据的长度) 
		Content-Language: zh-cn(服务端发送的语言类型) 
		Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)
		Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间)
		Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)
		Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)
		Transfer-Encoding: chunked(分块传递数据到客户端）  
		Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)
		Expires: -1//3种(服务端禁止客户端缓存页面数据)
		Cache-Control: no-cache(服务端禁止客户端缓存页面数据)  
		Pragma: no-cache(服务端禁止客户端缓存页面数据)   
		Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)  
		Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间)
	在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。



*/


var i = 1;
var i = 2;
var add = function() {
    var i = 0;
    return function()
{
        i++;
        console.log(i);
    }
}();
add();
代码存在几个变量没有被回收？

	代码回收规则如下：

	1.全局变量不会被回收。

	2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。

	3.只要被另外一个作用域所引用就不会被回收

	解析
	有3个变量没有被回收，首先是全局变量中的i，第二行会覆盖掉第一行（声明被忽略，赋值覆盖了），因此只有1个。
	第二个是var add，这个变量也没有回收，他定义了一个匿名函数，并将它赋给了add。
	第三个就是闭包中的变量i，闭包中的局部变量是不会被回收的，因此是3个变量没有被回收

if(!("b" in window)){
    let b = 1;
	console.log("ww",b);
}else{
	console.log("qqq",'b' in window);
}


if(! "a" in window){
    var a = 1;
}
alert(a);
请问 a 的结果是什么？
	解析：
	if(! "a" in window)这句代码的意思是：判断全局对象window中是否有变量a，如果没有变量a，就进入判断将a赋值为1
	但是由于变量的提前声明，以上代码与如下代码等价：
	var a；
	if（！“a” in  window ）{
		a=1;
	}
	alert(a);
	由于变量的提前声明特性，在执行这段代码之后，全局对象window中就已经存在a这个变量了
	所以不能进入判断，对a进行赋值
	所以a的值为undefined
	
	
	
JavaScript是解释性语言？	
	JS文件在完成之后，不会经过任何的编译。而是在运行时去解释执行。
	最好的例子就是，JS中一个函数有语法的错误，但是不会因为这个局部的错误而影响其他函数运行。 
		
	
下面代码中 a 在什么情况下会打印 1？	
	var a = ?;
	if(a == 1 && a == 2 && a == 3){
		conso.log(1);
	}	
	
	答案解析：这题考察的应该是类型的隐式转换,考引用类型在比较运算符时候,隐式转换会调用本类型toString或valueOf方法.
	
	利用toString
	let a = {
	  i: 1,
	  toString () {
		return a.i++
	  }
	}

	if(a == 1 && a == 2 && a == 3) {
	  console.log('1');
	}

	利用valueOf

	let a = {
	  i: 1,
	  valueOf () {
		return a.i++
	  }
	}

	if(a == 1 && a == 2 && a == 3) {
	  console.log('1');
	}

	数组这个就有点妖了

	var a = [1,2,3];
	a.join = a.shift;
	if(a == 1 && a == 2 && a == 3) {
	  console.log('1');
	}

	ES6的symbol

	let a = {[Symbol.toPrimitive]: ((i) => () => ++i) (0)};
	if(a == 1 && a == 2 && a == 3) {
	  console.log('1');
	}



给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
	示例：
	给定 nums = [2, 7, 11, 15], target = 9
	因为 nums[0] + nums[1] = 2 + 7 = 9
	所以返回 [0, 1]

	答案：
	function anwser (arr, target) {
	  let map = {}
	  for (let i = 0; i < arr.length; i++) {
		map[arr[i]] = i
	  }
	  for (let i = 0; i < arr.length; i++) {
		var d = target - arr[i]
		if (map[d]) {
		  return [i, map[d]]
		}
	  }
	  return new Error('404 not found')
	}
	
	
	
请写出如下代码的打印结果？
	function Foo() {
    Foo.a = function() {
        console.log(1)
    }
    this.a = function() {
        console.log(2)
    }
	}
	Foo.prototype.a = function() {
		console.log(3)
	}
	Foo.a = function() {
		console.log(4)
	}
	Foo.a();
	let obj = new Foo();
	obj.a();
	Foo.a();

	答案：
	function Foo() {
		Foo.a = function() {
			console.log(1)
		}
		this.a = function() {
			console.log(2)
		}
	}
	// 以上只是 Foo 的构建方法，没有产生实例，此刻也没有执行

	Foo.prototype.a = function() {
		console.log(3)
	}
	// 现在在 Foo 上挂载了原型方法 a ，方法输出值为 3

	Foo.a = function() {
		console.log(4)
	}
	// 现在在 Foo 上挂载了直接方法 a ，输出值为 4

	Foo.a();
	// 立刻执行了 Foo 上的 a 方法，也就是刚刚定义的，所以
	// # 输出 4

	let obj = new Foo();
	/* 这里调用了 Foo 的构建方法。Foo 的构建方法主要做了两件事：
	1. 将全局的 Foo 上的直接方法 a 替换为一个输出 1 的方法。
	2. 在新对象上挂载直接方法 a ，输出值为 2。
	*/

	obj.a();
	// 因为有直接方法 a ，不需要去访问原型链，所以使用的是构建方法里所定义的 this.a，
	// # 输出 2

	Foo.a();
	// 构建方法里已经替换了全局 Foo 上的 a 方法，所以
	// # 输出 1
	
	4 2 1
	
	
判断一个变量是不是数组？
	var arr = [1, 2, 3]
	Array.isArray(arr)
	arr instanceof Array
	arr.constructor === Array
	Object.prototype.toString.call(arr) === '[object Array]'
		每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，
		其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，
		会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。
	
观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知


拖拽功能实现原理和说明：
	1、说明：
	拖拽实现一般有两种方式，一种是使用html的新特性dragable，但是由于在火狐浏览器上dragable每拖拽一次会打开一个新的标签，
	尝试阻止默认行为和冒泡都无法解决，所以使用第二种方法来实现拖拽。第二种方法是使用js监听鼠标三个事件，配合节点操作来实现。

	2、实现原理：

		01-在允许拖拽的节点元素上，使用on来监听mousedown(按下鼠标按钮)事件，鼠标按下后，克隆当前节点

		02-监听mousemove(鼠标移动)事件，修改克隆出来的节点的坐标，实现节点跟随鼠标的效果

		03-监听mouseup(放开鼠标按钮)事件，将原节点克隆到鼠标放下位置的容器里，删除原节点，拖拽完成。
		
		
正则 g ?
	var str = "123#abc"; 
	var re = /abc/ig; 
	console.log(re.test(str)); //输出ture 
	console.log(re.test(str)); //输出false 
	console.log(re.test(str)); //输出ture 
	console.log(re.test(str)); //输出false 

	在创建正则表达式对象时如果使用了“g”标识符或者设置它了的﻿global属性值为ture时，
	那么新创建的正则表达式对象将使用模式对要将要匹配的字符串进行全局匹配。
	在全局匹配模式下可以对指定要查找的字符串执行多次匹配。每次匹配使用当前正则对象
	的lastIndex属性的值作为在目标字符串中开始查找的起始位置。lastIndex属性的初始值为0，
	找到匹配的项后lastIndex的值被重置为匹配内容的下一个字符在字符串中的位置索引，
	用来标识下次执行匹配时开始查找的位置。如果找不到匹配的项lastIndex的值会被设置为0。
	当没有设置正则对象的全局匹配标志时lastIndex属性的值始终为0，每次执行匹配仅查找字符串中第一个匹配的项。
	
	
&& (逻辑与) 优先级高于||（逻辑或）





https://blog.csdn.net/mrhaoxiaojun/article/details/78678858
　1、for 循环

　　体会 break 与 continue 的不同。

　　continue 结束本次循环，继续执行循环体； break 结束所有循环。在本例中当“2”满足条件后，继续进行下一轮判断，当’3‘满足条件后，break 结束所有循环。

 

　　2、forEach

　　这是ECMAScript 5数组的forEach方法 ,作用是遍历数组，常用的写法：

　　在forEach中，不能使用 continue 和 break ，可以使用 return 或 return false 跳出循环，效果与 for 中 continue 一样。注意该方法无法一次结束所有循环，需要一次性结束所有循环，还是老老实实使用for方法。

 

　　3、$.each()

　　这是jQuery的方法，用于遍历 DOM时很方便，偷懒必备。

　　在该方法中，同样是使用 return 或 return false 跳出循环，效果类似 效果与 for 中 break，结束所有循环。有兴趣的同学亲自动手尝试下。



























